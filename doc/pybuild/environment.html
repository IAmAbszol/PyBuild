<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pybuild.environment API documentation</title>
<meta name="description" content="Environment prepares a virtual environment for the PyBuild to run within …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pybuild.environment</code></h1>
</header>
<section id="section-intro">
<p>Environment prepares a virtual environment for the PyBuild to run within.</p>
<p>Every process in PyBuild requires a virtual environment to run inside to avoid any conflict
with a cleaned system Python.</p>
<p>Basic Usage:</p>
<p><code>environment = Environment('pybuildenv')</code></p>
<p><code>with</code> is available and easy to use with cleanup on <code>exit</code>.</p>
<pre><code>with Environment('pybuildenv') as environment:
    pass
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Environment prepares a virtual environment for the PyBuild to run within.

    Every process in PyBuild requires a virtual environment to run inside to avoid any conflict
    with a cleaned system Python.

    Basic Usage:

    ```environment = Environment(&#39;pybuildenv&#39;)```

    ```with``` is available and easy to use with cleanup on ```exit```.

    ```
    with Environment(&#39;pybuildenv&#39;) as environment:
        pass
    ```
&#34;&#34;&#34;
import logging
import pathlib
import os
import struct
import sys

from tempfile import NamedTemporaryFile
from typing import List, Tuple, Union

from pybuild import pip
from pybuild.utils import file_utils, os_utils, process_utils

# TODO: Create snapshot=False argument where the environment
# is saved and later restored after with context completes or
# __del__ occurs.
class Environment:

    def __init__(self, env_name : str):
        &#34;&#34;&#34;Creates an Environment for PyBuild to run in.

        Environment initialization function.

        Args:
            env_name Environment name to operate in.
        &#34;&#34;&#34;
        assert isinstance(env_name, str)
        self.__interpreter = pathlib.Path(sys.executable)
        self.__env_name = env_name
        self.__environment_path = pathlib.Path(env_name)

        # Setup basic logging
        logging.basicConfig(
            level=logging.INFO,
            format=&#39;%(message)s&#39;,
            handlers=[
                logging.StreamHandler()
            ]
        )


    def __enter__(self):
        return self


    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.__environment_path.exists():
            os_utils.remove_directory(str(self.__environment_path))


    def __str__(self):
        if self.__environment.exists():
            return self.__environment.absolute()
        raise FileNotFoundError(f&#39;Environment {self.__env_name} not found.&#39;)


    def _find_interpreter(self) -&gt; pathlib.Path:
        &#34;&#34;&#34;Finds the Python interepter which is later used to access various executables and scripts inside the environment.

        This function would be typically called when the Python interpreter changes locations, such as one would see when a new virtual environment is stood up.
        For the redundancy of searching for new paths, the function has been protected to avoid general outside use without better reason, potentially moving the interpreter?

        Returns:
            Path reference to interpreter.
        &#34;&#34;&#34;
        if pathlib.Path(sys.executable) == self.__interpreter:
            if os_utils.get_os() == os_utils.SupportedOS.WINDOWS:
                known_location = pathlib.Path(self.__environment_path, &#39;python.exe&#39;)
                if known_location.exists():
                    self.__interpreter = known_location
                else:
                    # Find the first occurrence of an interpreter - Windows only
                    for path in self.__environment_path.rglob(&#39;*&#39;):
                        if path.is_file() and os.access(path, os.X_OK):
                            if path.with_suffix(&#39;&#39;).name == &#39;python&#39; and path.suffix == &#39;.exe&#39;:
                                self.__interpreter = path
                                break
            elif os_utils.get_os() in [os_utils.SupportedOS.LINUX, os_utils.SupportedOS.MAC]:
                known_location = pathlib.Path(self.__environment_path, &#39;bin&#39;, &#39;python&#39;)
                if known_location.exists():
                    self.__interpreter = known_location
                else:
                    raise OSError(f&#39;Python interpreter doesn\&#39;t exist at known location {known_location.absolute()} on Linux OS.&#39;)
        return self.__interpreter


    def cleanup(self):
        &#34;&#34;&#34;Cleans the virtual environment if created else ignored.

        Shutil.rmtree deletes the directory, Windows this is a bit trickier and if any partition of the
        environment is currently accessed by other processes then rmtree will fail.
        &#34;&#34;&#34;
        if self.__environment_path.exists():
            os_utils.remove_directory(str(self.__environment_path))


    def dependency_exists(self, package) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;Checks if a dependency exists.

        Args:
            package: Package to check if it exists.

        Returns:
            Tuple of (package name, version) when the package exists else None.
        &#34;&#34;&#34;
        pkg_info = None
        output = pip.list(self, log_output=False)
        for line in output:
            installed_package = line.rstrip().split(&#39; &#39;)
            if package == installed_package[0]:
                pkg_info = (installed_package[0], installed_package[-1])
        return pkg_info


    def executables(self) -&gt; pathlib.Path:
        &#34;&#34;&#34;Returns the listing of the environments executables (Scripts: Windows, bin: Linux)

        Returns:
            List of files inside the executable directory.
        &#34;&#34;&#34;
        if os_utils.get_os() == os_utils.SupportedOS.WINDOWS:
            return [x for x in os_utils.retrieve_directory_listing(self.__env_name, &#39;Scripts&#39;) if x.is_file()]
        elif os_utils.get_os() in [os_utils.SupportedOS.LINUX, os_utils.SupportedOS.MAC]:
            return [x for x in os_utils.retrieve_directory_listing(self.__env_name, &#39;bin&#39;, &#39;python*&#39;) if x.is_file()]
        else:
            raise os_utils.PyBuildOSError()


    def info(self) -&gt; Tuple[str, int]:
        &#34;&#34;&#34;Reports environment information.

        Some build scripts may want to know the information of the environment being used,
        often this may be if the system requires a specific Python to launch the build script with.

        Returns:
            Tuple of (Python Version, Python Bit)
        &#34;&#34;&#34;
        return (sys.version_info, struct.calcsize(&#39;P&#39;) * 8)


    def libs(self) -&gt; List[pathlib.Path]:
        &#34;&#34;&#34;Returns the listing of the environments executables (Libs: Windows, lib64, lib: Linux)

        Returns:
            List of files inside the library directory.
        &#34;&#34;&#34;
        if os_utils.get_os() == os_utils.SupportedOS.WINDOWS:
            return os_utils.retrieve_directory_listing(self.__env_name, &#39;Libs&#39;)
        elif os_utils.get_os() in [os_utils.SupportedOS.LINUX, os_utils.SupportedOS.MAC]:
            return os_utils.retrieve_directory_listing(self.__env_name, &#39;lib/python*/&#39;)
        else:
            raise os_utils.PyBuildOSError()


    def name(self) -&gt; str:
        &#34;&#34;&#34;Returns name of environment.
        &#34;&#34;&#34;
        return self.__env_name


    def retrieve(self, file : str) -&gt; List[pathlib.Path]:
        &#34;&#34;&#34;Returns the file listing.

        Returns:
            List of files and directories inside the specified `file`.
        &#34;&#34;&#34;
        if file in self.__environment_dict:
            return self.__environment_dict


    def python(self) -&gt; pathlib.Path:
        &#34;&#34;&#34;Grabs the Python interpreter located inside the environment.
        Returns:
            The known location of the Python interpreter, by default sys.executable but may be changed later.
        &#34;&#34;&#34;
        return self.__interpreter


    def wipe(self) -&gt; bool:
        &#34;&#34;&#34;Wipes the entirety of the workspace of all installations.

        A developer may want the workspace they either created or are currently running in wiped prior to installing
        additional dependencies, etc. This function is only to be used by experienced users and should be avoided if possible.

        Returns:
            True if the environment was wiped successfully.

        Raises:
            OSError if the environment is unable to be wiped. The process runs through pip
        &#34;&#34;&#34;
        successful = False
        # Open a temporaryfile
        with NamedTemporaryFile(delete=False) as tmpfd:
            tmpfd.close()
            requirements_txt = pathlib.Path(tmpfd.name)
            pip.freeze(self, tmpfd.name)
            if requirements_txt.exists():
                if file_utils.process_requirements(requirements_txt):
                    pip.uninstall(self, None, requirement=tmpfd.name)
                successful = True
            os_utils.remove_file(requirements_txt)
        return successful</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pybuild.environment.Environment"><code class="flex name class">
<span>class <span class="ident">Environment</span></span>
<span>(</span><span>env_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an Environment for PyBuild to run in.</p>
<p>Environment initialization function.</p>
<h2 id="args">Args</h2>
<p>env_name Environment name to operate in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Environment:

    def __init__(self, env_name : str):
        &#34;&#34;&#34;Creates an Environment for PyBuild to run in.

        Environment initialization function.

        Args:
            env_name Environment name to operate in.
        &#34;&#34;&#34;
        assert isinstance(env_name, str)
        self.__interpreter = pathlib.Path(sys.executable)
        self.__env_name = env_name
        self.__environment_path = pathlib.Path(env_name)

        # Setup basic logging
        logging.basicConfig(
            level=logging.INFO,
            format=&#39;%(message)s&#39;,
            handlers=[
                logging.StreamHandler()
            ]
        )


    def __enter__(self):
        return self


    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.__environment_path.exists():
            os_utils.remove_directory(str(self.__environment_path))


    def __str__(self):
        if self.__environment.exists():
            return self.__environment.absolute()
        raise FileNotFoundError(f&#39;Environment {self.__env_name} not found.&#39;)


    def _find_interpreter(self) -&gt; pathlib.Path:
        &#34;&#34;&#34;Finds the Python interepter which is later used to access various executables and scripts inside the environment.

        This function would be typically called when the Python interpreter changes locations, such as one would see when a new virtual environment is stood up.
        For the redundancy of searching for new paths, the function has been protected to avoid general outside use without better reason, potentially moving the interpreter?

        Returns:
            Path reference to interpreter.
        &#34;&#34;&#34;
        if pathlib.Path(sys.executable) == self.__interpreter:
            if os_utils.get_os() == os_utils.SupportedOS.WINDOWS:
                known_location = pathlib.Path(self.__environment_path, &#39;python.exe&#39;)
                if known_location.exists():
                    self.__interpreter = known_location
                else:
                    # Find the first occurrence of an interpreter - Windows only
                    for path in self.__environment_path.rglob(&#39;*&#39;):
                        if path.is_file() and os.access(path, os.X_OK):
                            if path.with_suffix(&#39;&#39;).name == &#39;python&#39; and path.suffix == &#39;.exe&#39;:
                                self.__interpreter = path
                                break
            elif os_utils.get_os() in [os_utils.SupportedOS.LINUX, os_utils.SupportedOS.MAC]:
                known_location = pathlib.Path(self.__environment_path, &#39;bin&#39;, &#39;python&#39;)
                if known_location.exists():
                    self.__interpreter = known_location
                else:
                    raise OSError(f&#39;Python interpreter doesn\&#39;t exist at known location {known_location.absolute()} on Linux OS.&#39;)
        return self.__interpreter


    def cleanup(self):
        &#34;&#34;&#34;Cleans the virtual environment if created else ignored.

        Shutil.rmtree deletes the directory, Windows this is a bit trickier and if any partition of the
        environment is currently accessed by other processes then rmtree will fail.
        &#34;&#34;&#34;
        if self.__environment_path.exists():
            os_utils.remove_directory(str(self.__environment_path))


    def dependency_exists(self, package) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;Checks if a dependency exists.

        Args:
            package: Package to check if it exists.

        Returns:
            Tuple of (package name, version) when the package exists else None.
        &#34;&#34;&#34;
        pkg_info = None
        output = pip.list(self, log_output=False)
        for line in output:
            installed_package = line.rstrip().split(&#39; &#39;)
            if package == installed_package[0]:
                pkg_info = (installed_package[0], installed_package[-1])
        return pkg_info


    def executables(self) -&gt; pathlib.Path:
        &#34;&#34;&#34;Returns the listing of the environments executables (Scripts: Windows, bin: Linux)

        Returns:
            List of files inside the executable directory.
        &#34;&#34;&#34;
        if os_utils.get_os() == os_utils.SupportedOS.WINDOWS:
            return [x for x in os_utils.retrieve_directory_listing(self.__env_name, &#39;Scripts&#39;) if x.is_file()]
        elif os_utils.get_os() in [os_utils.SupportedOS.LINUX, os_utils.SupportedOS.MAC]:
            return [x for x in os_utils.retrieve_directory_listing(self.__env_name, &#39;bin&#39;, &#39;python*&#39;) if x.is_file()]
        else:
            raise os_utils.PyBuildOSError()


    def info(self) -&gt; Tuple[str, int]:
        &#34;&#34;&#34;Reports environment information.

        Some build scripts may want to know the information of the environment being used,
        often this may be if the system requires a specific Python to launch the build script with.

        Returns:
            Tuple of (Python Version, Python Bit)
        &#34;&#34;&#34;
        return (sys.version_info, struct.calcsize(&#39;P&#39;) * 8)


    def libs(self) -&gt; List[pathlib.Path]:
        &#34;&#34;&#34;Returns the listing of the environments executables (Libs: Windows, lib64, lib: Linux)

        Returns:
            List of files inside the library directory.
        &#34;&#34;&#34;
        if os_utils.get_os() == os_utils.SupportedOS.WINDOWS:
            return os_utils.retrieve_directory_listing(self.__env_name, &#39;Libs&#39;)
        elif os_utils.get_os() in [os_utils.SupportedOS.LINUX, os_utils.SupportedOS.MAC]:
            return os_utils.retrieve_directory_listing(self.__env_name, &#39;lib/python*/&#39;)
        else:
            raise os_utils.PyBuildOSError()


    def name(self) -&gt; str:
        &#34;&#34;&#34;Returns name of environment.
        &#34;&#34;&#34;
        return self.__env_name


    def retrieve(self, file : str) -&gt; List[pathlib.Path]:
        &#34;&#34;&#34;Returns the file listing.

        Returns:
            List of files and directories inside the specified `file`.
        &#34;&#34;&#34;
        if file in self.__environment_dict:
            return self.__environment_dict


    def python(self) -&gt; pathlib.Path:
        &#34;&#34;&#34;Grabs the Python interpreter located inside the environment.
        Returns:
            The known location of the Python interpreter, by default sys.executable but may be changed later.
        &#34;&#34;&#34;
        return self.__interpreter


    def wipe(self) -&gt; bool:
        &#34;&#34;&#34;Wipes the entirety of the workspace of all installations.

        A developer may want the workspace they either created or are currently running in wiped prior to installing
        additional dependencies, etc. This function is only to be used by experienced users and should be avoided if possible.

        Returns:
            True if the environment was wiped successfully.

        Raises:
            OSError if the environment is unable to be wiped. The process runs through pip
        &#34;&#34;&#34;
        successful = False
        # Open a temporaryfile
        with NamedTemporaryFile(delete=False) as tmpfd:
            tmpfd.close()
            requirements_txt = pathlib.Path(tmpfd.name)
            pip.freeze(self, tmpfd.name)
            if requirements_txt.exists():
                if file_utils.process_requirements(requirements_txt):
                    pip.uninstall(self, None, requirement=tmpfd.name)
                successful = True
            os_utils.remove_file(requirements_txt)
        return successful</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pybuild.environment.Environment.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cleans the virtual environment if created else ignored.</p>
<p>Shutil.rmtree deletes the directory, Windows this is a bit trickier and if any partition of the
environment is currently accessed by other processes then rmtree will fail.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self):
    &#34;&#34;&#34;Cleans the virtual environment if created else ignored.

    Shutil.rmtree deletes the directory, Windows this is a bit trickier and if any partition of the
    environment is currently accessed by other processes then rmtree will fail.
    &#34;&#34;&#34;
    if self.__environment_path.exists():
        os_utils.remove_directory(str(self.__environment_path))</code></pre>
</details>
</dd>
<dt id="pybuild.environment.Environment.dependency_exists"><code class="name flex">
<span>def <span class="ident">dependency_exists</span></span>(<span>self, package) ‑> Tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a dependency exists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package</code></strong></dt>
<dd>Package to check if it exists.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of (package name, version) when the package exists else None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dependency_exists(self, package) -&gt; Tuple[str, str]:
    &#34;&#34;&#34;Checks if a dependency exists.

    Args:
        package: Package to check if it exists.

    Returns:
        Tuple of (package name, version) when the package exists else None.
    &#34;&#34;&#34;
    pkg_info = None
    output = pip.list(self, log_output=False)
    for line in output:
        installed_package = line.rstrip().split(&#39; &#39;)
        if package == installed_package[0]:
            pkg_info = (installed_package[0], installed_package[-1])
    return pkg_info</code></pre>
</details>
</dd>
<dt id="pybuild.environment.Environment.executables"><code class="name flex">
<span>def <span class="ident">executables</span></span>(<span>self) ‑> pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the listing of the environments executables (Scripts: Windows, bin: Linux)</p>
<h2 id="returns">Returns</h2>
<p>List of files inside the executable directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def executables(self) -&gt; pathlib.Path:
    &#34;&#34;&#34;Returns the listing of the environments executables (Scripts: Windows, bin: Linux)

    Returns:
        List of files inside the executable directory.
    &#34;&#34;&#34;
    if os_utils.get_os() == os_utils.SupportedOS.WINDOWS:
        return [x for x in os_utils.retrieve_directory_listing(self.__env_name, &#39;Scripts&#39;) if x.is_file()]
    elif os_utils.get_os() in [os_utils.SupportedOS.LINUX, os_utils.SupportedOS.MAC]:
        return [x for x in os_utils.retrieve_directory_listing(self.__env_name, &#39;bin&#39;, &#39;python*&#39;) if x.is_file()]
    else:
        raise os_utils.PyBuildOSError()</code></pre>
</details>
</dd>
<dt id="pybuild.environment.Environment.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> Tuple[str, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Reports environment information.</p>
<p>Some build scripts may want to know the information of the environment being used,
often this may be if the system requires a specific Python to launch the build script with.</p>
<h2 id="returns">Returns</h2>
<p>Tuple of (Python Version, Python Bit)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; Tuple[str, int]:
    &#34;&#34;&#34;Reports environment information.

    Some build scripts may want to know the information of the environment being used,
    often this may be if the system requires a specific Python to launch the build script with.

    Returns:
        Tuple of (Python Version, Python Bit)
    &#34;&#34;&#34;
    return (sys.version_info, struct.calcsize(&#39;P&#39;) * 8)</code></pre>
</details>
</dd>
<dt id="pybuild.environment.Environment.libs"><code class="name flex">
<span>def <span class="ident">libs</span></span>(<span>self) ‑> List[pathlib.Path]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the listing of the environments executables (Libs: Windows, lib64, lib: Linux)</p>
<h2 id="returns">Returns</h2>
<p>List of files inside the library directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def libs(self) -&gt; List[pathlib.Path]:
    &#34;&#34;&#34;Returns the listing of the environments executables (Libs: Windows, lib64, lib: Linux)

    Returns:
        List of files inside the library directory.
    &#34;&#34;&#34;
    if os_utils.get_os() == os_utils.SupportedOS.WINDOWS:
        return os_utils.retrieve_directory_listing(self.__env_name, &#39;Libs&#39;)
    elif os_utils.get_os() in [os_utils.SupportedOS.LINUX, os_utils.SupportedOS.MAC]:
        return os_utils.retrieve_directory_listing(self.__env_name, &#39;lib/python*/&#39;)
    else:
        raise os_utils.PyBuildOSError()</code></pre>
</details>
</dd>
<dt id="pybuild.environment.Environment.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns name of environment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def name(self) -&gt; str:
    &#34;&#34;&#34;Returns name of environment.
    &#34;&#34;&#34;
    return self.__env_name</code></pre>
</details>
</dd>
<dt id="pybuild.environment.Environment.python"><code class="name flex">
<span>def <span class="ident">python</span></span>(<span>self) ‑> pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Grabs the Python interpreter located inside the environment.</p>
<h2 id="returns">Returns</h2>
<p>The known location of the Python interpreter, by default sys.executable but may be changed later.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python(self) -&gt; pathlib.Path:
    &#34;&#34;&#34;Grabs the Python interpreter located inside the environment.
    Returns:
        The known location of the Python interpreter, by default sys.executable but may be changed later.
    &#34;&#34;&#34;
    return self.__interpreter</code></pre>
</details>
</dd>
<dt id="pybuild.environment.Environment.retrieve"><code class="name flex">
<span>def <span class="ident">retrieve</span></span>(<span>self, file: str) ‑> List[pathlib.Path]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the file listing.</p>
<h2 id="returns">Returns</h2>
<p>List of files and directories inside the specified <code>file</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve(self, file : str) -&gt; List[pathlib.Path]:
    &#34;&#34;&#34;Returns the file listing.

    Returns:
        List of files and directories inside the specified `file`.
    &#34;&#34;&#34;
    if file in self.__environment_dict:
        return self.__environment_dict</code></pre>
</details>
</dd>
<dt id="pybuild.environment.Environment.wipe"><code class="name flex">
<span>def <span class="ident">wipe</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Wipes the entirety of the workspace of all installations.</p>
<p>A developer may want the workspace they either created or are currently running in wiped prior to installing
additional dependencies, etc. This function is only to be used by experienced users and should be avoided if possible.</p>
<h2 id="returns">Returns</h2>
<p>True if the environment was wiped successfully.</p>
<h2 id="raises">Raises</h2>
<p>OSError if the environment is unable to be wiped. The process runs through pip</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wipe(self) -&gt; bool:
    &#34;&#34;&#34;Wipes the entirety of the workspace of all installations.

    A developer may want the workspace they either created or are currently running in wiped prior to installing
    additional dependencies, etc. This function is only to be used by experienced users and should be avoided if possible.

    Returns:
        True if the environment was wiped successfully.

    Raises:
        OSError if the environment is unable to be wiped. The process runs through pip
    &#34;&#34;&#34;
    successful = False
    # Open a temporaryfile
    with NamedTemporaryFile(delete=False) as tmpfd:
        tmpfd.close()
        requirements_txt = pathlib.Path(tmpfd.name)
        pip.freeze(self, tmpfd.name)
        if requirements_txt.exists():
            if file_utils.process_requirements(requirements_txt):
                pip.uninstall(self, None, requirement=tmpfd.name)
            successful = True
        os_utils.remove_file(requirements_txt)
    return successful</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pybuild" href="index.html">pybuild</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pybuild.environment.Environment" href="#pybuild.environment.Environment">Environment</a></code></h4>
<ul class="two-column">
<li><code><a title="pybuild.environment.Environment.cleanup" href="#pybuild.environment.Environment.cleanup">cleanup</a></code></li>
<li><code><a title="pybuild.environment.Environment.dependency_exists" href="#pybuild.environment.Environment.dependency_exists">dependency_exists</a></code></li>
<li><code><a title="pybuild.environment.Environment.executables" href="#pybuild.environment.Environment.executables">executables</a></code></li>
<li><code><a title="pybuild.environment.Environment.info" href="#pybuild.environment.Environment.info">info</a></code></li>
<li><code><a title="pybuild.environment.Environment.libs" href="#pybuild.environment.Environment.libs">libs</a></code></li>
<li><code><a title="pybuild.environment.Environment.name" href="#pybuild.environment.Environment.name">name</a></code></li>
<li><code><a title="pybuild.environment.Environment.python" href="#pybuild.environment.Environment.python">python</a></code></li>
<li><code><a title="pybuild.environment.Environment.retrieve" href="#pybuild.environment.Environment.retrieve">retrieve</a></code></li>
<li><code><a title="pybuild.environment.Environment.wipe" href="#pybuild.environment.Environment.wipe">wipe</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>